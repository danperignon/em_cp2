/**
 * Minimal integrations with Memory and Filesystem servers
 * Keeps external dependencies simple and focused
 */

import type { DecompositionResult } from './types.js';
import { Logger } from '@em-cp2/shared';
// import { Client } from '@modelcontextprotocol/sdk/client/index.js';
// import { StdioClientTransport } from '@modelcontextprotocol/sdk/client/stdio.js';

export class ServerIntegrations {
  private logger: Logger;
  // private memoryClient?: Client;
  // private filesystemClient?: Client;

  constructor() {
    this.logger = new Logger('ServerIntegrations');
  }

  /**
   * Store successful decomposition pattern in Memory server
   */
  async storePattern(result: DecompositionResult): Promise<void> {
    try {
      // Simple pattern storage - just problem type and strategy
      const pattern = {
        problemType: result.problem.type,
        strategy: result.strategy.name,
        complexity: result.problem.complexity,
        stepCount: result.steps.length,
        timestamp: Date.now()
      };

      // In production, this would call the Memory server's entity creation
      // For now, we'll just log the intent
      this.logger.info(`Would store pattern: ${JSON.stringify(pattern)}`);
      
      // Example Memory server call (when integrated):
      // await this.memoryClient?.callTool('create_entities', {
      //   entities: [{
      //     name: `pattern-${result.problem.type}-${Date.now()}`,
      //     entityType: 'reasoning_pattern',
      //     observations: [pattern]
      //   }]
      // });
    } catch (error) {
      this.logger.error(`Failed to store pattern: ${error}`);
      // Don't throw - pattern storage is optional enhancement
    }
  }

  /**
   * Retrieve similar patterns from Memory server
   */
  async getSimilarPatterns(problemType: string): Promise<any[]> {
    try {
      // In production, this would query the Memory server
      this.logger.debug(`Would query patterns for problem type: ${problemType}`);
      
      // Example Memory server call (when integrated):
      // const response = await this.memoryClient?.callTool('search_entities', {
      //   query: problemType,
      //   entityTypes: ['reasoning_pattern'],
      //   limit: 5
      // });
      // return response?.entities || [];
      
      return [];
    } catch (error) {
      this.logger.error(`Failed to retrieve patterns: ${error}`);
      return [];
    }
  }

  /**
   * Generate documentation artifacts via Filesystem server
   */
  async generateArtifacts(result: DecompositionResult): Promise<{
    overview?: string;
    steps?: string[];
  }> {
    try {
      const timestamp = new Date().toISOString().split('T')[0];
      const baseDir = `sequential-thinking/${timestamp}-${result.problem.type}`;

      // Generate overview markdown
      this.generateOverviewMarkdown(result); // Will be used when filesystem integration is active
      
      // Generate individual step files
      const stepFiles = result.steps.map((step, index) => 
        this.generateStepMarkdown(step, index + 1)
      );

      // In production, these would be written via Filesystem server
      this.logger.info(`Would generate artifacts in: ${baseDir}`);
      
      // Example Filesystem server calls (when integrated):
      // await this.filesystemClient?.callTool('write_file', {
      //   path: `${baseDir}/solution-overview.md`,
      //   content: overview
      // });
      
      // for (let i = 0; i < stepFiles.length; i++) {
      //   await this.filesystemClient?.callTool('write_file', {
      //     path: `${baseDir}/steps/step-${i + 1}.md`,
      //     content: stepFiles[i]
      //   });
      // }

      return {
        overview: `${baseDir}/solution-overview.md`,
        steps: stepFiles.map((_, i) => `${baseDir}/steps/step-${i + 1}.md`)
      };
    } catch (error) {
      this.logger.error(`Failed to generate artifacts: ${error}`);
      return {};
    }
  }

  /**
   * Generate overview markdown content
   */
  private generateOverviewMarkdown(result: DecompositionResult): string {
    return `# Problem Decomposition Overview

## Problem
${result.problem.description}

**Type**: ${result.problem.type}  
**Complexity**: ${result.problem.complexity}

## Strategy
**Selected**: ${result.strategy.name}  
**Reasoning**: ${result.strategy.reasoning}

## Steps Summary
${result.steps.map((step, i) => `${i + 1}. ${step.description}`).join('\n')}

## Execution Notes
- Total steps: ${result.steps.length}
- Average confidence: ${(result.steps.reduce((sum, s) => sum + s.confidence, 0) / result.steps.length).toFixed(2)}
- Dependencies mapped: ${result.steps.some(s => s.dependencies.length > 0) ? 'Yes' : 'No'}

---
*Generated by Sequential Thinking MCP Server*`;
  }

  /**
   * Generate individual step markdown content
   */
  private generateStepMarkdown(step: any, stepNumber: number): string {
    return `# Step ${stepNumber}: ${step.description}

## Reasoning
${step.reasoning}

## Details
- **Confidence**: ${(step.confidence * 100).toFixed(0)}%
- **Dependencies**: ${step.dependencies.length > 0 ? step.dependencies.join(', ') : 'None'}

## Implementation Notes
[Add implementation details here]

---
*Part of Sequential Thinking decomposition*`;
  }
}